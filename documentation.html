<!DOCTYPE html>
<html>
<head>
<title>documentation.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="dokumentation-der-arduino-photokommunikation-brsubvon-tom-arlt-florian-k%C3%B6rwer-florian-meyer-henning-m%C3%BCller-cong-tai-phan-brsubhochschule-niederrhein-fb03-der-03012021subsub">Dokumentation der Arduino Photokommunikation <br><sub>von Tom Arlt, Florian Körwer, Florian Meyer, Henning Müller, Cong Tai Phan <br><sub>Hochschule Niederrhein FB03, der 03.01.2021</sub></sub></h1>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://github.com/Universumgames/hsnr_esp">GitHub link</a></li>
<li><a href="https://git.ide3.de/universumgames/esp">IDE3 link</a></li>
</ul>
<h2 id="einleitung">Einleitung</h2>
<p>Unsere Aufgabe war es als Gruppe für das Erstsemesterprojekt, im folgenenden &quot;ESP&quot; genannt, zwei Arduinos mithilfe von Leds und Photoresistoren miteinander kommunizieren zu lassen und unsere Arbeit hiermit zu dokumentieren. <br>
Die notwendigen Bauteile wurden uns hierfür pro Person von der Hochschule zur Verfügung gestellt:</p>
<ul>
<li>1x Arduino Uno</li>
<li>2x LM392 mit Photoresistor und Potenziometer</li>
<li>1x Breadboard</li>
<li>2x 330 Ohm Widerstände</li>
<li>verschied. LEDs</li>
<li>verschied. Kabel für das Breadboard</li>
<li><s>1x Potenziometer</s></li>
<li><s>1x Ultraschallsensor</s></li>
</ul>
<p>Da der Wissensstand innerhalb der Gruppe zum Thema Arduino sehr verschieden war, wurde nur zeitgleich und immer gemeinsam gearbeitet. Die Teilenhmer, welche bereits einiges an Erfahrung mit sich brachten, fungierten eher als Lehrpersonen, die den anderen das nötige Wissen überschaubar vermittelt haben, sodass alle dann gemeinsam die Aufgaben bearbeiten konnten.</p>
<h2 id="l%C3%B6sung-der-aufgabe">Lösung der Aufgabe</h2>
<h3 id="strategie">Strategie</h3>
<p>Das Entwickeln der Strategie für die Kommunikation, zu versuchen bereits bestehende Protokolle (als Basis) zu verwenden, war schnell erledigt. Der Versuch die nativen Protokolle des Arduinos zu verwenden scheiterte jedoch schnell, da alle Standardprotokolle viel zu schnell sind um mit LEDs verwendet werden zu können. Hinzukommt, dass uns zunächst entangen ist, dass der LM392 das Signal negiert ausgibt, welches uns erst einiges später auffiel. Schließlich entschlossen wir uns für eine serielle Kommunikation auf Basis des Protokolls <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>. Dieses Protokoll ist bei fast jedem modernen Microprocessor Hardwaremäßig implementiert für eine schneller Kommunikation. Bei diesem Protokoll ist in der Regel ein &quot;Master&quot; deklariert und mehrere &quot;Slaves&quot; welche alle gemeinsam an zwei Datenleitungen angeschlossen sind: &quot;Data&quot; und &quot;Clock&quot;. Immer wenn die Spannung auf &quot;Clock&quot; von 0V auf 3.3/5V ändert wird auf &quot;Data&quot; der Zustand (Bit) abgelesen, bis sich letztendlich, nach einigen Takten ein Byte (8 Bit) ergeben. Das Standardprotokoll arbeitet eigentlich mit Adressen um zu differnezieren an wen und von wem die Nachricht gesendet wurde. <br>
Unser Protokoll übernimmt dabei nur das Prinzip von &quot;Data&quot; und &quot;Clock&quot;, somit kann ein Empfangsmodul nur mit einem Sendermodul verbunden werden und vice versa.</p>
<h3 id="unsere-hardware-schematics">Unsere Hardware (Schematics)</h3>
<p>Hier einmal die Schematics in der Arduino Schematic Software <a href="https://fritzing.org/">fritzing</a><br>
<img src="Schematic.png" width="70%" heigth="auto">
<img src="Schematic_schem.png" width="70%" heigth="auto"></p>
<p>In dieser Schematic wurde der zum Arduino Uno funktionsidentische Arduino Nano verwendet und die Grafik übersitchlicher und kompakter zu gestalten. Beide Arduinoversionen besitzen denselben Prozessor (ATmega328P) und dieselben Pins. Die einzigen Unterschiede beider sind zum einen der Formfakor und zum anderen die Möglichkeit des Nanos, direkt auf ein Breadboard gesteckt werden zu können.
Dargestellt wurde hier ein einzelner Arduino, der in der Lage ist sowohl zu Empfangen als auch zu Senden, wenn das passend aufgebaute Gegenstück existiert.</p>
<h3 id="software">Software</h3>
<p>Unser Programm wurde in C++ für die Arduino IDE geschrieben, schaue man sich frühere Commits an (vor dem 18.12.2020) wurde noch für eine andere IDE gechrieben: PaltformIO welche zwar auf der Arduino IDE basiert, jedoch hier nur eine Extension für die IDE VS Code ist. Einfacheitshalber wurde jedoch entgültig zur Arduino IDE gewechselt.</p>
<p>LED_SendSimple.ino</p>
<pre class="hljs"><code><div><span class="hljs-comment">//init variables</span>
<span class="hljs-keyword">int</span> LED = <span class="hljs-number">2</span>;
<span class="hljs-keyword">int</span> incomingByte, ByteToSend;
<span class="hljs-keyword">int</span> SerialCounter = <span class="hljs-number">-1</span>;
<span class="hljs-comment">//serial input buffer used as a stack</span>
<span class="hljs-keyword">int</span> SerialBuffer[<span class="hljs-number">10</span>];
<span class="hljs-keyword">int</span> MaxValue = <span class="hljs-number">4</span>;
<span class="hljs-keyword">int</span> ClockCounter = <span class="hljs-number">0</span>;
boolean state = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> BitsToSend = <span class="hljs-number">-1</span>;


<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">//init serial interface</span>
  Serial.begin(<span class="hljs-number">9600</span>);
  pinMode(LED, OUTPUT);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">//read serial input if available</span>
  <span class="hljs-keyword">if</span>(Serial.available() &gt; <span class="hljs-number">0</span>){
    incomingByte = Serial.read();
    <span class="hljs-keyword">if</span> (incomingByte &gt;= <span class="hljs-number">32</span>){
      <span class="hljs-comment">//increment serial counter</span>
      SerialCounter++;
      <span class="hljs-comment">//store recieved byte from serial into stack buffer</span>
      SerialBuffer[SerialCounter] = incomingByte;
    }
  }
  ClockCounter++;
  <span class="hljs-keyword">if</span>(ClockCounter &gt;= MaxValue){
    ClockCounter = <span class="hljs-number">0</span>;
    state = !state;
    <span class="hljs-comment">//if serial buffer is not empty</span>
    <span class="hljs-keyword">if</span>(SerialCounter &gt; <span class="hljs-number">-1</span>){
      <span class="hljs-comment">//if current byte to send is not set</span>
      <span class="hljs-keyword">if</span>(BitsToSend &lt;= <span class="hljs-number">-1</span>){
        <span class="hljs-comment">//set byte to send</span>
        BitsToSend = SerialBuffer[SerialCounter];
        Serial.print(<span class="hljs-string">"Sending byte: "</span>);
        Serial.println(BitsToSend);
      }<span class="hljs-keyword">else</span>{
        digitalWrite(LED, state);
        delay(<span class="hljs-number">70</span>);
        <span class="hljs-comment">//if led is on</span>
        <span class="hljs-keyword">if</span>(state){
          <span class="hljs-comment">//decrease bit to send</span>
          BitsToSend--;
          <span class="hljs-comment">//if byte is sent, finish transmission</span>
          <span class="hljs-keyword">if</span>(BitsToSend &lt;= <span class="hljs-number">0</span>){
            BitsToSend = <span class="hljs-number">-1</span>;
            SerialCounter--;
            delay(<span class="hljs-number">4</span>*<span class="hljs-number">70</span>);
            digitalWrite(LED, LOW);
            delay(<span class="hljs-number">5000</span>);
          }
        }
      }
    }
  }
  delay(<span class="hljs-number">70</span>);
}
</div></code></pre>
<p>LED_ReecieveSimple.ino</p>
<pre class="hljs"><code><div><span class="hljs-comment">//init variables</span>
<span class="hljs-keyword">int</span> LDR = <span class="hljs-number">2</span>;
<span class="hljs-keyword">int</span> ClockCounter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> FlashCounter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> MaxValue = <span class="hljs-number">2500</span>;
<span class="hljs-keyword">int</span> HighFlanke = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> Flash;
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> lastmillis = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">//init serial monitor</span>
  Serial.begin(<span class="hljs-number">9600</span>);
  <span class="hljs-comment">//init pinmode</span>
  pinMode(LDR, INPUT);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
  ClockCounter++;
  <span class="hljs-comment">//red LDR value</span>
  Flash = digitalRead(LDR);
  <span class="hljs-keyword">if</span>(Flash){
    HighFlanke = <span class="hljs-number">1</span>;
  }
  <span class="hljs-comment">//if LDR value changes from HIGH to LOW</span>
  <span class="hljs-keyword">if</span>(!Flash &amp;&amp; HighFlanke){
    HighFlanke = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//increment flashcounter    </span>
    <span class="hljs-keyword">int</span> delta = millis()- lastmillis;    
  <span class="hljs-keyword">if</span>(delta &gt;= <span class="hljs-number">500</span>){
    FlashCounter++;
    ClockCounter = <span class="hljs-number">0</span>;
  }
  Serial.print(FlashCounter);
    Serial.print(<span class="hljs-string">": "</span>);
    Serial.print(delta);
    Serial.println(<span class="hljs-string">"ms"</span>); 
    lastmillis = millis();
  }
  <span class="hljs-comment">//if transmission for one character finished</span>
  <span class="hljs-keyword">if</span>((ClockCounter &gt;= MaxValue) &amp;&amp; FlashCounter &gt; <span class="hljs-number">0</span>){
    <span class="hljs-comment">//write flashcounter as character</span>
    Serial.write(FlashCounter);
    Serial.println(FlashCounter);
    <span class="hljs-comment">//reset flashcounter for next character</span>
    FlashCounter = <span class="hljs-number">0</span>;
  }<span class="hljs-keyword">else</span> delay(<span class="hljs-number">1</span>);
}
</div></code></pre>
<p>Link zum Aktuellen Programmcode: <a href="https://github.com/Universumgames/hsnr_esp/tree/master/LightCom">Github</a>, <a href="https://git.ide3.de/universumgames/esp/-/tree/master/LightCom">IDE3</a> <br>
Link zum aufbereiteten/alternativen Code (eigenständig entwickelt von Tom Arlt):  <a href="https://github.com/Universumgames/hsnr_esp/tree/universumgames/LightCom">Github</a>, <a href="https://git.ide3.de/universumgames/esp/-/tree/universumgames/LightCom">IDE3</a></p>
<h2 id="verwendung">Verwendung</h2>
<p>(Übersetzt und aufbereitet aus <a href="Readme.md">Readme.md</a>)
Um unser Projekt zu verwenden, müssen zwei Schaltungen aufgebaut sein, wobei mindestens zwei LEDs und zwei Empfänger aufgebaut sein müssen, um zumindest die Einseitige Kommunikation testen zu können. Zu beachten ist, dass jedes LED-LM392 Paar zu allen anderen Paaren abgeschirmt sein sollte, da es sonst zu Interferrenzen kommen kann. Zudem muss das Potenziometer des LM392 eingestellt werden nur die dazugehörige eingeschaltete LED zu erkennen und nicht das Umgebungslicht. Bei der Erstellung der LED-LM392 Paare ist auf die Unterscheidung zwischen &quot;Data&quot; und &quot;Clock&quot; zu achten:</p>
<pre>
Arduino 1       <-> Arduino 2
sender_clock    <-> reciever_clock
sender_data     <-> reciever_data
reciever_clock  <-> sender_clock
reciever_data   <-> sender_data
</pre>
<p>Ist das Programm einmal auf beiden Arduinos hochgeladen, ist die Arduino IDE (o.ä.) nicht mehr notwendig. Nun kann über einen Seriellen Monitor, wie zum Beispiel der intergrierte Monitor der <a href="https://www.arduino.cc/en/software">Arduino IDE</a> oder  <a href="https://www.putty.org/">Putty</a> über den Arduino kommuniziert werden. In diesen Tools muss noch der Port, über den der Arduino angeschlossen ist, angegeben werden, sowie die Baud Rate des Seriellen Monitor, welche hier <code>9600</code> beträgt.</p>
<h2 id="reflexion">Reflexion</h2>
<p>Wie schon in <code>Strategie</code> erwähnt, war die grundsätzliche Strategie schnell gefunden, nur das ausarbeiten hat, dank der Rückschläge, etwas länger gedauert.
Nach den ersten Rückschlägen und das Festsetzen auf die entgültige Implementationsstrategie war auch das Entwickeln eines ersten Gerüsts relativ straight forward. Das Debuggen sowie ein ordentlicher Aufbau der Schaltung war dann die größere Herausforderung. Da durch ständig wechselnde Lichtverhältnisse der Photoresistor nicht immer wie gewünscht funktionierte, verzögerte sich das Programm-Debuggen ungemein. Erst nach vielen Stunden rumgrübelns, rumschrauben und ausprobieren, stellte sich als einzige zuverlässige Methode eine eigene Blackbox für jedes LED-LM392 Paar heraus.</p>
<h2 id="zusammenfassung">Zusammenfassung</h2>
<p>Die Aufgaben waren, wenn auch leicht missverständlich organisiert, einfach zu bearbeiten. Wir hatten schnell eine grundsätzliche Strategie für die Programmentwicklung gefunden und hatten binnen einiger Stunden nach den Fehlversuchen einen ersten ordentlichen Prototypen stehen. Somit hatten wir die grundsätzliche Aufgabe &quot;zwei Arduinos mithilfe von LEDs und LDRs kommunizieren zu lassen&quot; gelöst. Währenddessen sich die Ersten bereits an die Dokumentation gesetzt hatten, haben sich andere im Internet auf die Suche gemacht ein angemessenes Schematic-Tool ausfindig zu machen und eine digitale Schaltung zu erstellen.<br>
Erst später, als alle gemeinsam an der Dokumentation arbeiteten, fiel auf, dass die Aufgaben der Anleitung zum Kommunikationssystem zu bearbeiten sind. Als die Dokumentation bereits in den letzten Zügen war, wurden die zusätzlichen Aufgaben fertiggestellt, dabei schafften wir es jedoch nicht die Kommunikation der Arduinos mithilfe dieser Aufgaben über die digitalen Kommunikationswege erfolgreich zu realisieren, da die Photoresistoren die LEDs nur unzureichend erkennen konnten. Zusätzlich kamen noch Timingproblemen hinzu, die durch die Kommunikation entstanden sind.<br>
Ingesamt hat die Gruppe gut zusammengearbeitet und ist recht zügig zu einer ersten Lösung gekommen.</p>

</body>
</html>
