<!DOCTYPE html>
<html>
<head>
<title>documentation.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="dokumentation-der-arduino-photokommunikation-brsubvon-tom-arlt-florian-k%C3%B6rwer-florian-meyer-henning-m%C3%BCller-brsubhochschule-niederrhein-fb03-der-03012021subsub">Dokumentation der Arduino Photokommunikation <br><sub>von Tom Arlt, Florian Körwer, Florian Meyer, Henning Müller <br><sub>Hochschule Niederrhein FB03, der 03.01.2021</sub></sub></h1>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://github.com/Universumgames/hsnr_esp">GitHub link</a></li>
<li><a href="https://git.ide3.de/universumgames/esp">IDE3 link</a></li>
</ul>
<h2 id="einleitung">Einleitung</h2>
<p>Unsere Aufgabe war es als Gruppe für das Erstsemesterprojekt, im folgenenden &quot;ESP&quot; genannt, zwei Arduinos mithilfe von Leds und Photoresistoren miteinander kommunizieren zu lassen und unsere Arbeit hiermit zu dokumentieren. <br>
Die notwendigen Bauteile wurden uns hierfür pro Person von der Hochschule zur verfügung gestellt:</p>
<ul>
<li>1x Arduino Uno</li>
<li>2x LM392 mit Photoresistor und Potenziometer</li>
<li>1x Breadboard</li>
<li>2x 330 Ohm Widerstände</li>
<li>verschied. LEDs</li>
<li>verschied. Kabel für das Breadboard</li>
<li><s>1x Potenziometer</s></li>
<li><s>1x Ultraschallsensor</s></li>
</ul>
<p>Da der Wissensstand innerhalb der Gruppe zum Thema Arduino sehr verscheiden war, wurde nur zeitgleich und immer gemeinsam gearbeitet. Die Teilenhmer, welche bereits einiges an Erfahrung mit sich brachten, fungierten eher als Lehrperson, die den anderen das Nötige Wissen überschaubar vermittelt haben, sodass alle dann gemeinsam die Aufageb bearbeiten konnten.</p>
<h2 id="l%C3%B6sung-der-aufgabe">Lösung der Aufgabe</h2>
<h3 id="strategie">Strategie</h3>
<p>Das Entwickeln der Strategie für die Kommunikation, zu versuchen bereits bestehende Protokolle (als Basis) zu verwenden, war schnell erledigt. Der Versuch die Nativen Protokolle des Arduinos zu verwenden scheiterte jedoch schnell, da alle Standardprotokolle viel zu schnell sind um mit LEDs verwendet werden zu können. Hinzukommt, dass uns zunächst entangen ist, dass der LM392 das Signal negiert ausgibt, welches uns erst einiges später auffiel. Schließlich entschlossen wir uns für eine serielle Kommunikation auf Basis des Protokolls <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>. Dieses Protokoll ist bei fast jedem modernen Microprocessor Hardwaremäßig implementiert für eine schneller Kommunikation. Bei diesem Protokoll ist in der Regel ein &quot;Master&quot; deklariert und mehrere &quot;Slaves&quot; welche alle gemeinsam an zwei Datenleitungen angeschlossen sind: &quot;Data&quot; und &quot;Clock&quot;. Immer wenn die Spannung auf &quot;Clock&quot; von 0V auf 3.3/5V ändert wird auf &quot;Data&quot; der Zustand (Bit) abgelesen, bis sich letztendlich, nach einigen Takten ein Byte (8 Bit) ergeben. Das Standardprotokoll arbeitet eigentlich mit Adressen um zu differnezieren an wen und von wem die Nachricht gesendet wurde. <br>
Unser Protokoll übernimmt dabei nur das Prinzip von &quot;Data&quot; und &quot;Clock&quot;, somit kann ein Empfangsmodul nur mit einem Sendermodul verbunden werden und vice versa.</p>
<h3 id="unsere-hardware-schematics">Unsere Hardware (Schematics)</h3>
<p>Hier einmal die Schematics in der Arduino Schematic Software <a href="https://fritzing.org/">fritzing</a><br>
<img src="Schematic.png" width="70%" heigth="auto">
<img src="Schematic_schem.png" width="70%" heigth="auto"></p>
<p>In dieser Schematic wurde der zum Arduino Uno funktionsidentische Arduino nano verwendet und die Grafik übersitchlicher und kompakter zu gestalten. Beide Arduino-versionen besitzen denselben Prozessor (ATmega328P) und dieselben Pins. Die einzigen Unterschiede beider sind der Formfakor und die Funktion des Nanos, dass er direkt auf ein Breadboard gestekct werden kann.
Dargestellt wurde hier ein einzelner Arduino, der in der lage ist sowohl zu Empfangen als auch zu senden, wenn das passend aufgebaute Gegenstück existiert.</p>
<h3 id="software">Software</h3>
<p>Unser Programm wurde in C++ für die Arduino IDE geschrieben, schaue man sich frühere Commits an (vor dem 18.12.2020) wurde noch für eine andere IDE gechrieben: PaltformIO welche zwar auf der Arduino IDE basiert, jedoch hier niur eine Extension für die IDE VS Code ist. Einfacheitshalber wurde jedoch entgültig zur Arduino IDE gewechselt.</p>
<pre class="hljs"><code><div><span class="hljs-comment">//declare variables</span>
<span class="hljs-keyword">int</span> sender_clock = <span class="hljs-number">6</span>;
<span class="hljs-keyword">int</span> sender_data = <span class="hljs-number">7</span>;
<span class="hljs-keyword">int</span> reciever_clock = <span class="hljs-number">4</span>;
<span class="hljs-keyword">int</span> reciever_data = <span class="hljs-number">3</span>;
<span class="hljs-keyword">int</span> incomingByte = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> reciever_clock_2 = <span class="hljs-number">2</span>;
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> last_millis = <span class="hljs-number">0</span>;
byte temp;
<span class="hljs-keyword">int</span> recieve_index = <span class="hljs-number">7</span>;
byte b;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">//attach Interrupts to not having to worry about reading from one pin</span>
  attachInterrupt(digitalPinToInterrupt(reciever_clock), clock_interrupt_start, FALLING);
  attachInterrupt(digitalPinToInterrupt(reciever_clock), clock_interrupt_end, RISING);
  <span class="hljs-comment">//initialize Serial Monitor</span>
  Serial.begin(<span class="hljs-number">9600</span>);
  <span class="hljs-comment">//set pin modes</span>
  pinMode(sender_clock, OUTPUT);
  pinMode(sender_data, OUTPUT);
  pinMode(reciever_clock, INPUT);
  pinMode(reciever_data, INPUT);
  pinMode(reciever_clock_2, INPUT);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">//check if serial queue contains items</span>
  <span class="hljs-keyword">if</span> (Serial.available() &gt; <span class="hljs-number">0</span>)
  {
    <span class="hljs-comment">//read incoming byte (charactere)</span>
    incomingByte = Serial.read();
    <span class="hljs-comment">//send each bit seperately to serial monitor for debugging and to other arduino</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">7</span>; i &gt;= <span class="hljs-number">0</span>; i--)
    {
      Serial.print(bitRead(incomingByte, i));
      sendBit(bitRead(incomingByte, i));
    }
    Serial.println();
  }
}

<span class="hljs-comment">//read incoming bits</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clock_interrupt_start</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">bool</span> dataval = !digitalRead(reciever_data);
  bitWrite(temp, recieve_index, dataval);
}

<span class="hljs-comment">//verify incoming bit</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clock_interrupt_end</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">//calculate delta since clock fell, to check for hazards</span>
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> delta = millis() - last_millis;
  <span class="hljs-comment">//if delta &gt; 100ms, it's nit a hazard or glitch from the photoresistor</span>
  <span class="hljs-keyword">if</span> (delta &gt; <span class="hljs-number">100</span>)
  {
    <span class="hljs-comment">//write temporary byte to "longterm" byte</span>
    b = temp;
    <span class="hljs-comment">//reduce recieve index to move to next bit</span>
    recieve_index--;
    <span class="hljs-comment">//if recieve_index &lt; 0 we have successfully recieved a byte and print that to the serial monitor</span>
    <span class="hljs-keyword">if</span> (recieve_index &lt; <span class="hljs-number">0</span>)
    {
      Serial.print(b);
      <span class="hljs-comment">//reset recieving variables to default state</span>
      recieve_index = <span class="hljs-number">7</span>;
      b = <span class="hljs-number">0x0</span>;
    }
    <span class="hljs-comment">//reset for delta caluclation</span>
    last_millis = millis();
  }
  <span class="hljs-keyword">else</span>
  {
    <span class="hljs-comment">//if a glitch was detected, delete temporarily recieved bit</span>
    temp = b;
  }
}

<span class="hljs-comment">//send single bit</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendBit</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bitt)</span>
</span>{
  <span class="hljs-comment">//change data pin</span>
  digitalWrite(sender_data, bitt);
  delayMicroseconds(<span class="hljs-number">10</span>);
  <span class="hljs-comment">//change clock to HIGH</span>
  digitalWrite(sender_clock, HIGH);
  <span class="hljs-comment">//wait to be able to differentiate between valid bit and a hazard</span>
  delayMicroseconds(<span class="hljs-number">500</span>);
  <span class="hljs-comment">//change both pins to default state</span>
  digitalWrite(sender_clock, LOW);
  digitalWrite(sender_data, LOW);
  delayMicroseconds(<span class="hljs-number">5</span>);
}
</div></code></pre>
<p>Link zum Aktuellen Programmcode: <a href="https://github.com/Universumgames/hsnr_esp/tree/master/LightCom">Github</a>, <a href="https://git.ide3.de/universumgames/esp/-/tree/master/LightCom">IDE3</a> <br>
Link zum aufbereiteten/alternativen Code (eigenständig entwicklet von Tom Arlt):  <a href="https://github.com/Universumgames/hsnr_esp/tree/universumgames/LightCom">Github</a>, <a href="https://git.ide3.de/universumgames/esp/-/tree/universumgames/LightCom">IDE3</a></p>
<h2 id="verwendung">Verwendung</h2>
<p>(Übersetzt und aufbereitet aus <a href="Readme.md">Readme.md</a>)
Um unser Projekt zu verwenden, müssen zwei Schaltungen aufgebaut sein, wobei mindestens zwei LEDs und zwei Empfänger aufgebaut sein müssen um zumindest die Einseitige Kommunikation testen zu können. Zu beachten ist, dass jedes LED-LM392 Paar zu allen anderen Paaren abgeschirmt sein sollte, da es sonst zu Interferrenzen kommen kann. Zudem muss das Potenziometer des LM392 eingestellt werden nur die dazugehörige eingeschaltete LED zu erkennen und nicht das Umgebungslicht. Bei der Erstellung der LED-LM392 Paare ist auf die Unterscheidung zwischen &quot;Data&quot; und &quot;Clock&quot; zu achten:</p>
<pre>
Arduino 1       <-> Arduino 2
sender_clock    <-> reciever_clock
sender_data     <-> reciever_data
reciever_clock  <-> sender_clock
reciever_data   <-> sender_data
</pre>
<p>Ist das Programm einmal auf beiden Arduinos hochgeladen, ist die Arduino IDE (o.ä.) nicht mehr notwending. Nun kann über einen Seriellen Monitor, wie zum Beispiel der Intergrierte der <a href="https://www.arduino.cc/en/software">Arduino IDE</a> oder  <a href="https://www.putty.org/">Putty</a> über den Arduino kommuniziert werden. In diesen Tools muss noch der Port, über den der Arduino angeschlossen ist, angegeben werden, sowie die Baud Rate des Seriellen Monitor, welche in <code>config.hpp</code> eingesehen und verändert werden kann, der Standard ist hier <code>9600</code>.</p>
<h2 id="reflexion">Reflexion</h2>
<p>Wie schon in <code>Strategie</code> erwähnt, war die grundsätzliche Strategie schnell gefunden, nur das ausarbeiten hat, dank der Rückschläge, etwas länger gedauert.
Nach den ersten Rücklucken und das festsetzen auf die entgültige Implementationsstrategie war auch das Entwickeln eines ersten Gerüsts relativ straight forward. Das Debuggen sowie ein ordentlicher Aufbau der Schaltung war dann die größere Herausforderung. Da durch ständig wechselnde Lichtverhältnisse der Photoresistor nicht immer wie gewünsch funktionierte, verzögerte sich das Programm-Debuggen ungemein. Erst nach vielen Stunden rumgrübelns, rumschrauben und ausprobieren, stellte sich als einzige zufverlässige Methode eine eigene Blackbox für jedes LED-LM392 Paar heraus.</p>
<h2 id="zusammenfassung">Zusammenfassung</h2>

</body>
</html>
